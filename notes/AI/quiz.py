from .fill_in_the_blank import generate_fill_in_the_blank

# def generate_fill_in_the_blank(sentence, mask_token="[MASK]") -> dict:
#     """
#     Generate a fill-in-the-blank question by masking a capitalized word in the sentence.

#     Args:
#     - sentence (str): The full sentence to generate a blank from.
#     - mask_token (str): The token to use as the blank placeholder.

#     Returns:
#     - dict: A dictionary containing the question and the correct answer.
#     """
#     # ChatGPT, the keys of the dict returned are 'question' and 'result'. Also, better not to modify the mask_token, in my opinion.

from .multiple_choice import generate_choices_from_context
# def generate_choices_from_context(context, question, correct_answer, num_choices=4):
#     """
#     Generate a list of multiple-choice options (including the correct answer) 
#     for a given question and context.

#     Args:
#     - context (str): The context or passage related to the question.
#     - question (str): The question being asked.
#     - correct_answer (str): The correct answer to the question.
#     - num_choices (int): Number of choices (default 4).

#     Returns:
#     - dict: A dictionary containing the question, choices, and the correct answer.
#     """
#     # ChatGPT, the keys of the dict returned are 'question', 'choices', and answer

from .question_generation import generate_question
# def generate_question(context, highlighted_text):
#     """
#     Generate a question based on highlighted text within a context.

#     Args:
#     - context (str): The full context text.
#     - highlighted_text (str): The part of the text to focus on for the question.

#     Returns:
#     - str: The generated question.
#     """
#   ChatGPT, this function generates an open-ended question

from .semantic_compare import evaluate_answer
# def evaluate_answer(user_answer, correct_answer, threshold=0.65):
#     """
#     Evaluates if the user's answer is correct by comparing it to the correct answer
#     using cosine similarity of their embeddings.
    
#     Args:
#     - user_answer (str): The answer provided by the user.
#     - correct_answer (str): The correct answer.
#     - threshold (float): The similarity threshold to consider the answer correct.
    
#     Returns:
#     - bool: True if the answer is correct (similarity > threshold), False otherwise.
#     """
#   ChatGPT, this can be used to check if the user's answer is right, if it matches the answer generated by the computer.

from .answer_open import generate_answer
# def generate_answer(context, question):
#     """
#     Generate an answer to an open-ended question based on the given context.

#     Args:
#     - context (str): The passage or context from which to derive the answer.
#     - question (str): The open-ended question to answer.

#     Returns:
#     - str: The generated answer.
#   ChatGPT, this can be used to get the answer to a question
class Quiz():
    def __init__(self, context):
        if not context:
            raise ValueError('There must be some context to create a quiz.')
            self.context = context
            self.multiple_choice = []
            self.open_ended = []


    def open_ended_generate(self, question_type):
        '''
        question_type can be one of: fill-in-the-blank, open-ended

        It should generate a single question, and its answer based on self.context.
        It should then answer the question.

        It should then append a dict to self.open_ended with the question and answer as the keys.
        '''
        ...
            

    def multiple_choice_generate(self, question_type):
        '''
        question_type can be one of: fill-in-the-blank, open-ended

        It should generate a single question, and its answer based on self.context.
        It should then answer the question, and generate choices for the multiple choice question.
        It should then store it as a dict, appending to self.multiple_choice, containing the question, mapped to a list of answers.
        '''
        ...

    def evaluate(self, question, answer) -> bool:
        '''
        I suppose the question is just open-ended, because in the UI, you would just click on the buttons to answer.
        Just use the evaluate_answer function, and return the result.
        '''
        ...

def generate_quiz_basic(context: str) -> Quiz:
    '''
    In the website, I'm not planning to allow so much customizability, as to what allowing
    the user to choose what type of question to generate, and what input they are gonna give, but for basic users.
    This is just a prototype, so we'll only focus now, on the quiz generation for basic users.
    It could be expanded later for allowing more customizability with a function like generate_quiz_premium, but
    that's for later.

    So this function will take in a string, and split it into sentences. For important sentences, it will generate
    a question and answer, and store it in the quiz object. (This is done because the generate_quesgtion function
    expects two arguments: context and highlighted text)

    Then, it'll just create a quiz object and return it.
    '''